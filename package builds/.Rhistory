#Modify the quoted text to search for a different taxon
#note that the code will work with only a genus, or with
#partial names (first four letters)
#########################################
genus='Dinobryon'
species='cylindricum'
#######################################
search.string=
paste('www.algaebase.org/search/?species=',
genus,'%20',
species,sep='')
browseURL(search.string)
algae.search=function(genus,species)
{
URL=paste('www.algaebase.org/search/?species=',
genus,'%20',
species,sep='')
url.get=GET(URL)
parsed=htmlParse(url.get)
tabs=readHTMLTable(parsed)
results.tab=tabs[[1]]
colnames(results.tab)[2]='Current name if different'
# pg=read_html(url.get) #rvest
# links.parsed=html_attr(html_nodes(pg, "a"), "href")
# links.parsed<-links.parsed[grep('results',links.parsed)]
# links.parsed=links.parsed[seq(1,length(links.parsed),by=2)]
links.parsed=xpathSApply(parsed,"//a/@href")
links.parsed<-links.parsed[grep('results',links.parsed)]
links.parsed=links.parsed[seq(1,length(links.parsed),by=2)]
results.tab$link=paste('www.algaebase.org',links.parsed,sep='')
return(results.tab)
}
algae.search.checked.novar=function(genus,species)
{
#simply returns the binomial name if confirmed. else returns na
URL=paste('www.algaebase.org/search/?species=',
genus,'%20',
species,sep='')
url.get=GET(URL)
parsed=htmlParse(url.get)
tabs=readHTMLTable(parsed)
results.tab=tabs[[1]]
colnames(results.tab)[2]='Current name if different'
res.names=results.tab$Name
#check if there are any verified names.
goodnames=unique(as.character(res.names[-c(grep('var',res.names),grep('Unchecked',res.names))]))
if(length(goodnames)==1)
{
return(goodnames)
}else
{
return(NA)
}
}
xpathSApply(PARSED, "//a/@href")
#example bbc scraper from fredheir.github
# bbcScraper <- function(url){
# SOURCE <-  getURL(url,encoding="UTF-8")
# PARSED <- htmlParse(SOURCE)
# title=xpathSApply(PARSED, "//h1[@class='story-header']",xmlValue)
# date=as.character(xpathSApply(PARSED, "//meta[@name='OriginalPublicationDate']/@content"))
# if (is.null(date))    date <- NA
# if (is.null(title))    title <- NA
# return(c(title,date))
# }
# #url="http://www.bbc.co.uk/search/news/?page=3&q=Russia"
# SOURCE <-  getURL(url,encoding="UTF-8")
# PARSED <- htmlParse(SOURCE)
# xpathSApply(PARSED, "//a/@href")
# unique(xpathSApply(PARSED, "//a[@class='title linktrack-title']/@href"))
# #OR xpathSApply(PARSED, "//div[@id='news content']/@href")
xpathSApply(parsed,"//a[@class='sForm']/@href")
#paste0!!!!
res=algae.search(genus,species)
#the first list object is a table of matching names
res
###some information from the results
#number of potential variations
num.vars=dim(res)[1]
#number of variations verified by algaebase
num.verified=length(res$Name[-grep('Unchecked',res$Name)])
#verified variations
res$Name[-grep('Unchecked',res$Name)]
#potential synonyms
unique(res[,2])
#we can also follow one of the links and extract information from the resulting page
#In this example, I am arbitrarily selecting the verified name with no var.
#we could automatically select one name from the results list based on criteria like that.
best.name=res$Name[9]
best.name.link=res$link[9]
test2=htmlParse(GET(best.name.link))
plain.text <- xpathSApply(test2, "//p", xmlValue)
synonym=plain.text[grep('Synonym',plain.text)]
status=plain.text[grep('Status',plain.text)]
###checking the taxonomic status of the selected name and listing any synonyms
synonym
status
#####These are just some examples of the kinds of information that can be extracted from algaebase using R.
#we need to create pseudocode describing the workflow that we want:
#for exampmle- is it enough to loop through a list of species names and make sure that they have at least one verified match with no preferred synonyms?
genus='Chlamydocapsa'
species=''
#######################################
search.string=
paste('www.algaebase.org/search/?species=',
genus,'%20',
species,sep='')
browseURL(search.string)
res=algae.search(genus,species)
res
num.vars=dim(res)[1]
num.verified=length(res$Name[-grep('Unchecked',res$Name)])
res$Name[-grep('Unchecked',res$Name)]
res$Name<-as.character(res$Name)
res
num.vars=dim(res)[1]
num.verified=length(res$Name[-grep('Unchecked',res$Name)])
res$Name[-grep('Unchecked',res$Name)]
grep('Unchecked',res$Name)
res$Name
unchecked.indices=grep('Unchecked',res$Name)
if(length(unchecked.indices)>0)  res$Name=res$Name[grep('Unchecked',res$Name)]
res$Name
unique(res[,2])
nametest<-read.csv('~/gleon/Geisha/phyto_package/phytonametest.csv')
goodnames=strsplit(as.character(nametest$PhytoName),split=' ')[[1]]
wrongnames=strsplit(as.character(nametest$WrongName),split=' ')[[1]]
wrongnames
binomial.nametest=data.frame(c(goodnames,wrongnames))
binomial.nametest
binomial.nametest=data.frame(rbind(goodnames,wrongnames))
binomial.nametest
goodnames
wrongnames
binomial.nametest[1,]=c(goodnames,wrongnames))
binomial.nametest[1,]=c(goodnames,wrongnames)
binomial.nametest=data.frame(goodgenus,goodspp,wronggenus,wrongspp)
binomial.nametest[1,]=c(goodnames,wrongnames)
binomial.nametest=data.frame(goodgenus=NULL,goodspp=NULL,wronggenus=NULL,wrongspp=NULL)
binomial.nametest[1,]=c(goodnames,wrongnames)
binomial.nametest
binomial.nametest=matrix(c(goodnames,wrongnames),nrow=1)
binomial.nametest
names(binomial.nametest)=c('goodgen','goodspp','wronggen','wrongspp')
binomial.nametest
colnames(binomial.nametest)=c('goodgen','goodspp','wronggen','wrongspp')
binomial.nametest
write.csv(binomial.nametest,'binomial_phytoname_test.csv')
goodnames=strsplit(as.character(nametest$PhytoName),split=' ')
goodnames
goodnames=unlist(strsplit(as.character(nametest$PhytoName),split=' '))
goodnames
nametest<-read.csv('~/gleon/Geisha/phyto_package/phytonametest.csv')
nametest
?agrep
check1=nametest$GoodSpp[1]
wrong1=nametest$WrongSpp[1]
agrep(check1,wrong1,max.distance=1)
agrep(check1,wrong1,max.distance=2)
agrep(check1,wrong1,max.distance=0)
agrep(check1,wrong1,max.distance=.1)
wrong1='flos-aquuu'
agrep(check1,wrong1,max.distance=0)
agrep(check1,wrong1,max.distance=1,value=T)
agrep(check1,wrong1,max.distance=2,value=T)
agrep(wrong1,check1,max.distance=2,value=T)
agrep(wrong1,check1,max.distance=1,value=T)
agrep(wrong1,nameteset$GoodSpp,max.distance=1,value=T)
agrep(wrong1,nametest$GoodSpp,max.distance=1,value=T)
agrep(wrong1,nametest$GoodSpp,max.distance=2,value=T)
bestmatch=function(enteredName,possibleNames,maxErr=3)
{
for(i in 0:maxErr)
{
match=agrep(enteredName,possibleNames,max.distance=i)
if(length(match)==1) {return(match)}
if(length(match)>1) {return('multiplePartialMatch')}
}
}
bestmatch(wrong1,nametest$GoodSpp)
match=agrep(enteredName,possibleNames,max.distance=i,value=T)
bestmatch=function(enteredName,possibleNames,maxErr=3)
{
for(i in 0:maxErr)
{
match=agrep(enteredName,possibleNames,max.distance=i,value=T)
if(length(match)==1) {return(match)}
if(length(match)>1) {return('multiplePartialMatch')}
}
}
wrong1
bestmatch(wrong1,nametest$GoodSpp)
nametest$matches=''
nametest$matches=''
for(i in 1:dim(nametest)[1])
{
nametest$matches[i]=bestmatch(nametest$WrongSpp[i],nametest$GoodSpp)
}
nametest
nametest$genusmatches=''
nametest$sppmatches=''
for(i in 1:dim(nametest)[1])
{
nametest$genusmatches[i]=bestmatch(nametest$WrongGen[i],nametest$GoodGen)
nametest$sppmatches[i]=bestmatch(nametest$WrongSpp[i],nametest$GoodSpp)
}
nametest$genusmatches
nametest
###test code to correct spelling errors
###example data file with small errors in both genus and species
nametest<-read.csv('~/gleon/Geisha/phyto_package/phytonametest.csv')
####function for spelling matches. maxErr refers to maximum acceptable number of insertions/deletions/etc.
####first argument is the name to check, and the second is a vector of correctly spelled names
####second argument will eventually come from returns from an algaebase search.
####if two accepted names are equally different from the one you are checking, the function will not try to differentiate between them
bestmatch=function(enteredName,possibleNames,maxErr=3)
{
for(i in 0:maxErr)
{
match=agrep(enteredName,possibleNames,max.distance=i,value=T)
if(length(match)==1) {return(match)}
if(length(match)>1) {return('multiplePartialMatch')}
}
}
######creating columns for the best matches found
nametest$genusmatches=''
nametest$sppmatches=''
#####calling the function for all four names- matching each 'wrongname' against all of the 'rightnames'
for(i in 1:dim(nametest)[1])
{
nametest$genusmatches[i]=bestmatch(nametest$WrongGen[i],nametest$GoodGen)
nametest$sppmatches[i]=bestmatch(nametest$WrongSpp[i],nametest$GoodSpp)
}
nametest
###test code to correct spelling errors
###example data file with small errors in both genus and species
nametest<-read.csv('~/gleon/Geisha/phyto_package/phytonametest.csv')
####function for spelling matches. maxErr refers to maximum acceptable number of insertions/deletions/etc.
####first argument is the name to check, and the second is a vector of correctly spelled names
####second argument will eventually come from returns from an algaebase search.
####if two accepted names are equally different from the one you are checking, the function will not try to differentiate between them
bestmatch=function(enteredName,possibleNames,maxErr=3)
{
for(i in 0:maxErr)
{
match=agrep(enteredName,possibleNames,max.distance=i,value=T)
if(length(match)==1) {return(match)}
if(length(match)>1) {return('multiplePartialMatch')}
}
}
######creating columns for the best matches found
nametest$genusmatches=''
nametest$sppmatches=''
#####calling the function for all four names- matching each 'wrongname' against all of the 'rightnames'
for(i in 1:dim(nametest)[1])
{
nametest$genusmatches[i]=bestmatch(nametest$WrongGen[i],nametest$GoodGen)
nametest$sppmatches[i]=bestmatch(nametest$WrongSpp[i],nametest$GoodSpp)
}
nametest
###test code to correct spelling errors
###example data file with small errors in both genus and species
nametest<-read.csv('~/gleon/Geisha/phyto_package/phytonametest.csv')
####function for spelling matches. maxErr refers to maximum acceptable number of insertions/deletions/etc.
####first argument is the name to check, and the second is a vector of correctly spelled names
####second argument will eventually come from returns from an algaebase search.
####if two accepted names are equally different from the one you are checking, the function will not try to differentiate between them
bestmatch=function(enteredName,possibleNames,maxErr=3)
{
for(i in 0:maxErr)
{
match=agrep(enteredName,possibleNames,max.distance=i,value=T)
if(length(match)==1) {return(match)}
if(length(match)>1) {return('multiplePartialMatch')}
}
}
######creating columns for the best matches found
nametest$genusmatches=''
nametest$sppmatches=''
#####calling the function for all four names- matching each 'wrongname' against all of the 'rightnames'
for(i in 1:dim(nametest)[1])
{
nametest$genusmatches[i]=bestmatch(nametest$WrongGen[i],nametest$GoodGen)
nametest$sppmatches[i]=bestmatch(nametest$WrongSpp[i],nametest$GoodSpp)
}
nametest
library(tcltk2)
library(tcltk)
library(tcltk)
library(tcltk2)
library("metagear", lib.loc="C:/Program Files/R/R-3.4.0/library")
library(metagear)
biocLite('EBImage')
source("https://bioconductor.org/biocLite.R")
biocLite('EBImage')
library(metagear)
library(EBImage)
library(metagear)
?plot_PRISMA
?abstract_screener
library(metagear)
?PDFs_collect
?abstract_screener
?effort_initialize
data(example_references_metagear)
head(example_references_metagear)
write.csv(example_references_metagear,'~/gleon/Geisha/metagear_ex.csv')
summary(lm)
.011/0.017
5/8
176+120+18
314/40
load("C:/Users/vpatil/Documents/gleon/Geisha/phyto_package/github/MFG_CSR.rda")
View(mfg.csr)
View(mfg.csr)
load("C:/Users/vpatil/Documents/gleon/Geisha/phyto_package/github/sppMFG.rda")
print(ipm.lsgo,digits=3)
44693*.02
44693*.03
44693*.04
55/12
plot.new()
x.range=c(10^-1,10^-3)
y.range=c(6,30)
x.range=log(x.range)
lines(x.range,y.range)
plot(x.range,y.range)
x.range=c(10^-1,10^-3)
x.range=log(x.range,10)
plot(x.range,y.range)
x.range=c(10^-1,10^3)
x.range=log(x.range,10)
plot(x.range,y.range)
x.range=seq(-1,3,by=.01)
y.range=seq(6,30,by=.01)
plot(x.range,y.range)
y.range=seq(6,30,length.out = length(x.range))
plot(x.range,y.range)
plot(exp(x.range),y.range)
x.range=seq(10^-1,10^3,by=.1)
y.range=seq(6,30,length.out = length(x.range))
plot(exp(x.range),y.range)
plot(log(x.range,1),y.range)
plot(log(x.range,10),y.range)
library(devtools)
install_github("vppatil/GEISHA_phytoplankton/phytoDiv/PhytoDiv")
install.packages("~/gleon/Geisha/phyto_package/GEISHA_phytoplankton_github_shared/phytoDiv/PhytoDiv_1.0.0.tar.gz", repos = NULL, type = "source")
library(PhytoDiv)
?traits_to_mfg
install_github("vppatil/GEISHA_phytoplankton/phytoDiv/PhytoDiv")
library(phytoDiv)
library(PhytoDiv)
?PhytoDiv
description
?description
?vignette
vignette("PhytoDiv")
library(taxize)
??taxize
library(BAStag)
install_github("eldarrak/FLightR") # note the version
require(devtools)
install_github("eldarrak/FLightR") # note the version
install.packages('FLightR')
install.packages('FLightR')
install.packages('rgeos')
280/40
1230+1188
]
240*3.
2114-1038-225
179*4
716-200
146*4
library(BAStag)
library(SGAT)
library(devtools)
library(httr)
set_config(config(ssl_verifypeer = 0L))
install_github("eldarrak/FLightR@0.3.6") # note the version
library(FLightR)
install.packages('Rcpp')
install.packages('Rcpp')
library(FLightR)
?get.tags.data
plot_slopes_by_location(Proc.data=Proc.data, location=c(cap.lat,cap.long))
library(geoknife)
all_webdata<-query("webdata")
head(all_webdata)
all_titles<-title(all_webdata)
grep('Alaska',all_titles)
all_titles[grep('Alaska',all_titles)]
ak.proj.title=all_titles[1]
ak.proj.fabric<-webdata(all_webdata[ak.proj.title])
ak.proj.fabric
query(ak.proj.fabric,"variables")
abstract(all_webdata)[77]
variables(ak.proj.fabric)='tmx'
query(ak.proj.fabric,"times")
gina.fabric=webdata(url="http://ndvi.gina.alaska.edu/metrics")
query(gina.fabric,"variables")
gina.fabric=webdata(url="http://ndvi.gina.alaska.edu/metrics/emodis")
query(gina.fabric,"variables")
gina.fabric=webdata(url="http://ndvi.gina.alaska.edu/metrics/emodis?")
query(gina.fabric,"variables")
gina.fabric=webdata(url="http://static.gina.alaska.edu/NPS_products/eMODIS_NDVI/eMODIS_derived_NDVI_metrics/version_1.0/")
query(gina.fabric,"variables")
gina.fabric=webdata(url="http://ndvi.gina.alaska.edu/metrics/emodis")
query(gina.fabric,"variables")
gina.fabric=webdata(url="http://ndvi.gina.alaska.edu/2010/modis")
query(gina.fabric,"variables")
gina.fabric=webdata(url="https://ndvi.gina.alaska.edu/2010/modis")
query(gina.fabric,"variables")
490/120
#short script to install preliminary phytoDiv package on github
#comment the next line if you have already installed devtools
# install.packages('devtools')
# install.packages('httr')
library(devtools)
library(httr)
#uncomment next line if you get an error during github install, then try again.
#set_config(config(ssl_verifypeer = 0L))
#the next line will only need to be run once, or whenever you need an updated version of the code
install_github("vppatil/GEISHA_phytoplankton/package builds/algaeClassify",ref = "master")
library(algaeClassify)
#view help documentation for functions
help(traits_to_mfg)
traits_to_mfg(1,"large",1,0,NA,0,0,"Euglenophyceae","Euglenales")
#short script to install preliminary phytoDiv package on github
#comment the next line if you have already installed devtools
# install.packages('devtools')
# install.packages('httr')
library(devtools)
library(httr)
#uncomment next line if you get an error during github install, then try again.
#set_config(config(ssl_verifypeer = 0L))
#the next line will only need to be run once, or whenever you need an updated version of the code
install_github("vppatil/GEISHA_phytoplankton/package builds/algaeClassify",ref = "working")
library(algaeClassify)
citation("algaeClassify") #preliminary citation before the manuscript comes out.
#view package description. All available functions listed at the bottom:
library(help="algaeClassify")
#view help documentation for functions
help(traits_to_mfg)
citation("algaeClassify")
traits_to_mfg(1,"large",1,0,NA,0,0,"Euglenophyceae","Euglenales")
species_phyto_convert('Anabaena','')
# define the package name
thePackage <- "algaeClassify"
# set directory to the package development folder
setwd("~/gleon/Geisha/phyto_package/GEISHA_phytoplankton_github_shared/package builds/")
# create new bare-bones package in development folder
# NOTE: only run package creation script once
#install.packages("devtools"); # make sure your have the most recent version
#install.packages("roxygen2"); # make sure your have the most recent version
library(devtools); library(roxygen2)
create(thePackage)
roxygenize(thePackage)
# define the package name
thePackage <- "algaeClassify"
# set directory to the package development folder
setwd("~/gleon/Geisha/phyto_package/GEISHA_phytoplankton_github_shared/package builds/")
# create new bare-bones package in development folder
# NOTE: only run package creation script once
#install.packages("devtools"); # make sure your have the most recent version
#install.packages("roxygen2"); # make sure your have the most recent version
library(devtools); library(roxygen2)
create(thePackage)
roxygenize(thePackage)
# add dataset to package
lakegeneva <- read.csv("~/gleon/Geisha/datasets/phyto_data/lakegeneva_stub.csv", header = TRUE,stringsAsFactors = F)
# use_data(library_MFG, pkg = thePackage, internal = TRUE, overwrite = TRUE)
use_data(lakegeneva, pkg = thePackage, overwrite = TRUE)
setwd('~/gleon/Geisha/phyto_package/GEISHA_phytoplankton_github_shared/package builds/')# use_data(library_MFG, pkg = thePackage, internal = TRUE, overwrite = TRUE)
load('sppMFG.rda')
use_data(species.mfg.library, pkg = thePackage, overwrite = TRUE)
load('MFG_CSR.rda')
mfg.csr$CSR[3]='R'
use_data(mfg.csr, pkg = thePackage, overwrite = TRUE)
# constructs binaries
library(devtools);
# creates bundle to submit to CRAN (*.tar.zip file found in development folder)
build(thePackage, manual = FALSE)
# error checks prior to submission (all errors and warnings need to be addressed)
check(thePackage)
document(thePackage)
path <- find.package(thePackage)
system(paste(shQuote(file.path(R.home("bin"), "R")), "CMD", "Rd2pdf", shQuote(path)))
document(thePackage)
path <- find.package(thePackage)
system(paste(shQuote(file.path(R.home("bin"), "R")), "CMD", "Rd2pdf", shQuote(path)))
rm(list=ls())
# install.packages('devtools')
library(devtools)
library(httr)
set_config(config(ssl_verifypeer = 0L))
#the next line will only need to be run once, or whenever you need an updated version of the code
install_github("vppatil/GEISHA_phytoplankton/package builds/algaeClassify",ref="working")
library(algaeClassify)
citation("algaeClassify") #preliminary citation before the manuscript comes out.
#view package description. All available functions listed at the bottom:
library(help="algaeClassify")
#view help documentation for functions
help(traits_to_mfg)
help(mfg_csr)
help("mfg_csr_convert")
mfg_csr_convert("11a-NakeChlor")
rm(list=ls())
mfg.csr
rm(list=ls())
ls()
mfg.csr
